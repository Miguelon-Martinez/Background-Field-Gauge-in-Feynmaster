(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
This is the Preamble.m file, a Mathematica routine for FeynRules where we make some useful
definitions and lists.

Created by: Duarte Fontes
Email: duartefontes@tecnico.ulisboa.pt
Last update: 10.02.2021
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)

(* FeynMaster signature *)
Print["This Notebook was automatically generated by FeynMaster."];
Print["FeynMaster: created by Duarte Fontes and Jorge C. Rom√£o."];
Print["Version " <> FMversion <> " (" <> FMdate <> ")"];
Print["Please cite: Comput.Phys.Commun. 256 (2020) 107311, arXiv: 1909.05876."];
Print["Please do not forget to cite FeynRules, QGRAF and FeynCalc as well"];

(* Some initial instructions *)
 FR$DSign = -1;
 G5 := ProjP - ProjM

(* Creation of adapted particles lists *)
aux1 = {};
palist = {};
Do[Do[aux1 = Append[aux1, StringTake[ToString[PartList[[i, 1, 1]]], 1]];
	If[Length[PartList[[i, 2]]] > 1,
	If[StringTake[ToString[PartList[[i, 2, j, 1]]], -1]=="-"||StringTake[ToString[PartList[[i, 2, j, 1]]], -1]=="+",
	aux1 = Append[aux1, StringDrop[ToString[PartList[[i, 2, j, 1]]], -1]],
	aux1 = Append[aux1, ToString[PartList[[i, 2, j, 1]]]]],
	aux1 = Append[aux1, ToString[PartList[[i, 1, 2]]]]];
	palist = Append[palist, aux1];
	aux1 = {}, {j, 1, Length[PartList[[i, 2]]]}], {i, 1,Length[PartList]}];
palist2 = {};
Do[If[palist[[i, 1]] != "W",
		palist2 = Append[palist2, palist[[i]]]], {i, 1, Length[palist]}];
palist3 = palist2 // ToExpression;

MyWeyls={};
Do[If[StringTake[ToString[InputForm[PartList[[i,1,1]]]],1]=="W",
MyWeyls=Append[MyWeyls,ToString[InputForm[PartList[[i,1,2]]]]]],{i,1,Length[PartList]}];

(* A list concerning propagators *)
auxprop={}
Do[auxprop = Append[auxprop, {}], {i, 1, Length[palist2]}];
Do[	auxprop[[i]] = Append[auxprop[[i]], palist2[[i, 2]]];
	If[ToString[ToExpression[palist2[[i, 2]]<>"bar"]/.antimap]==palist2[[i, 2]],
	auxprop[[i]] = Append[auxprop[[i]], palist2[[i, 2]]<>"bar"],
	auxprop[[i]] = Append[auxprop[[i]], palist2[[i, 2]]]];
	auxprop[[i]] = Append[auxprop[[i]], If[palist2[[i, 1]] == "F" || palist2[[i, 1]] == "U", "-", "+"]], {i, 1, Length[palist2]}];

(* A function to separate parcels of an expression into a list *)
Parc=Function[exp,Module[{auxp},
auxp=Replace[exp, HoldPattern[Plus[a___]] :> {a}];
auxp]];
(* A function to contract Lorentz indices *)
MyContract = Function[{exp}, Module[{x0, auxc, x1},
    x0 = ExpandIndices[exp];
    auxc = {ME[a_, b_]*ME[b_, c_] -> ME[a, c], FV[p_, K_] FV[p_, K_] -> p^2, FV[p_, Index[Lorentz, x_]] -> FV[p, x]};
    x1 = x0 /. auxc;
    x1]];
(* A function to solve equations *)
MySolve = Function[{exp, var}, Module[{x0, x1, x2}, x0 = Coefficient[exp, var];
    x1 = x0 var;
    x2 = var -> -(exp - x1)/x0;
    x2]];
(* A way to avoid the anoying Sqrt[x^2]: *)
mysqrt=Function[exp,Module[{auxp1,auxp2},
auxp1=Sqrt[exp];
auxp2=auxp1/.{Sqrt[x_^2]->x, Sqrt[x_^2*y_]->x*Sqrt[y]};
auxp2]];

massmap2 = {};
Do[membercoin = 0;
  Do[If[ToString[InputForm[M$ClassesDescription[[i, 2, p, 1]]]] == "ClassMembers", membercoin = 1], {p, 1, Length[M$ClassesDescription[[i, 2]]]}];
  Do[If[ToString[InputForm[M$ClassesDescription[[i, 2, j, 1]]]] == "Mass",
  				If[membercoin == 0,
  						Do[If[ToString[InputForm[M$ClassesDescription[[i, 2, k, 1]]]] == "ClassName", 
       							massmap2 = Append[massmap2, ToExpression[ToString[M$ClassesDescription[[i, 2, k, 2]]] <> "->" <> ToString[M$ClassesDescription[[i, 2, j, 2]]]]]],
       							{k, 1, Length[M$ClassesDescription[[i, 2]]]}], 
     					Do[If[ToString[InputForm[M$ClassesDescription[[i, 2, k, 1]]]] == "ClassMembers", 
       							Do[massmap2 = Append[massmap2, ToExpression[ToString[M$ClassesDescription[[i, 2, k, 2, l]]] <> "->" <> ToString[M$ClassesDescription[[i, 2, j, 2, l]]]]],
       							{l, 1, Length[M$ClassesDescription[[i, 2, k, 2]]]}]], {k, 1, Length[M$ClassesDescription[[i, 2]]]}]]], {j, 1, Length[M$ClassesDescription[[i, 2]]]}], {i, 1, Length[M$ClassesDescription]}];

masstrade = {};
Do[Do[If[ToString[palist3[[i, 2]]] == ToString[massmap2[[j, 1]]],
		masstrade = Append[masstrade, ToExpression["m" <> ToString[palist3[[i, 2]]]	<> "->" <> ToString[massmap2[[j, 2]]]]]],
					{j, 1, Length[massmap2]}], {i,1, Length[palist3]}];

(* List with some of the restrictions of the restrictions file *)
MyRestr = {};
Do[If[! StringContainsQ[ToString[M$Restrictions[[i, 1]] // InputForm],"_"], 
			MyRestr = Append[MyRestr, ToExpression[StringReplace[ToString[InputForm[M$Restrictions[[i]]]],":>" -> "->"]]]], {i, 1, Length[M$Restrictions]}];

(* MyExpandIndices is the same as ExpandIndices, but does not use the restrictions (of the restrictions file) *)
MyEI={};
Do[Do[
If[ToString[InputForm[M$ClassesDescription[[i,2,j,1]]]]=="Definitions",
			Do[MyEI=Append[MyEI,ToExpression[ToString[ToString[M$ClassesDescription[[i,2,j,2,k,1]]]<>"bar"<>"->"<>"HC["<>
											ToString[InputForm[M$ClassesDescription[[i,2,j,2,k,2]]]]<>"]"]]];
			   MyEI=Append[MyEI,M$ClassesDescription[[i,2,j,2,k]]],{k,1,Length[M$ClassesDescription[[i,2,j,2]]]}]],{j,1,Length[M$ClassesDescription[[i,2]]]}],
											{i,1,Length[M$ClassesDescription]}];
MyEI=DeleteDuplicates[MyEI];
MyExpandIndices=Function[exp,Module[{aux,exp1},exp1=Expand[exp//.MyEI]]];

(* Tricks concerning the projectors: *)
notensdots = {TensDot[Ga[Index[Lorentz, mu_]], ProjM] -> Ga[mu].ProjM, TensDot[Ga[Index[Lorentz, mu_]], ProjP] -> Ga[mu].ProjP};
todots = {ProjM Ga[Index[Lorentz, mu_]] -> Ga[Index[Lorentz, mu]].ProjM, ProjP Ga[Index[Lorentz, mu_]] -> Ga[Index[Lorentz, mu]].ProjP};
assodots = {x_ .ProjM + x_ .ProjP -> x};
pprops = {ProjM + ProjP -> 1};

(* Some tricks concerning colour *)
mygluind={};
mycolset={};
Nclistpre={};
colcoin=0;
myglu="";
myglugh="";
Do[Do[Do[Do[Do[
	If[ToString[InputForm[M$GaugeGroups[[h0, 2, h1a, 1]]]] ==  "StructureConstant"
	&& ToString[InputForm[M$GaugeGroups[[h0, 2, h1a, 2]]]] == "f"
	&& ToString[InputForm[M$ClassesDescription[[j0, 2, j1, 1]]]] == "ClassName"
	&& ToString[InputForm[M$GaugeGroups[[h0, 2, h1b, 1]]]] == "GaugeBoson"
	&& ToString[InputForm[M$GaugeGroups[[h0, 2, h1b, 2]]]] == ToString[InputForm[M$ClassesDescription[[j0, 2, j1, 2]]]], 
		colcoin += 1;
		Do[If[ToString[InputForm[M$GaugeGroups[[h0, 2, h2, 1]]]] ==  "Representations",
			Do[mycolset=Append[mycolset,M$GaugeGroups[[h0, 2, h2, 2, h3, 2]]],{h3,1,Length[M$GaugeGroups[[h0, 2, h2, 2]]]}];
		Do[If[StringTake[ToString[InputForm[M$ClassesDescription[[n0, 1]]]], 1] == "F",
			Do[If[ToString[InputForm[M$ClassesDescription[[n0, 2, n1, 1]]]]=="Indices",
				Do[If[MemberQ[mycolset, M$ClassesDescription[[n0, 2, n1, 2, n2, 1]]],
					Do[If[ToString[InputForm[M$ClassesDescription[[n0, 2, n3, 1]]]]=="ClassMembers",
						Do[Nclistpre=Append[Nclistpre,M$ClassesDescription[[n0, 2, n3, 2, n4]]],
						{n4,1,Length[M$ClassesDescription[[n0, 2, n3, 2]]]}]],{n3, 1, Length[M$ClassesDescription[[n0,2]]]}]],
						{n2,1,Length[M$ClassesDescription[[n0, 2, n1, 2]]]}]],{n1,1,Length[M$ClassesDescription[[n0,2]]]}]],
						{n0,1,Length[M$ClassesDescription]}]],{h2, 1, Length[M$GaugeGroups[[h0, 2]]]}];
		myglu = ToString[ToExpression[ToString[InputForm[M$GaugeGroups[[h0, 2, h1b, 2]]]]]];
		Do[If[ToString[InputForm[M$ClassesDescription[[j0, 2, m, 1]]]]=="Indices",
					mygluind=M$ClassesDescription[[j0, 2, m, 2]]],{m,1,Length[M$ClassesDescription[[j0, 2]]]}];
	Do[If[StringTake[ToString[InputForm[M$ClassesDescription[[n0, 1]]]], 1] == "U",
			Do[If[ToString[InputForm[M$ClassesDescription[[n0, 2, n1, 1]]]]=="Indices"&&mygluind!={}&&M$ClassesDescription[[n0, 2, n1, 2]]==mygluind,
				Do[If[ToString[InputForm[M$ClassesDescription[[n0, 2, n2, 1]]]]=="ClassName",
				myglugh = ToString[ToExpression[ToString[InputForm[M$ClassesDescription[[n0, 2, n2, 2]]]]]]],
				{n2,1,Length[M$ClassesDescription[[n0,2]]]}]],{n1,1,Length[M$ClassesDescription[[n0,2]]]}]],{n0,1,Length[M$ClassesDescription]}]],
		{j1, 1, Length[M$ClassesDescription[[j0, 2]]]}],
		{j0,1, Length[M$ClassesDescription]}],
		{h1b, 1, Length[M$GaugeGroups[[h0, 2]]]}],
		{h1a, 1, Length[M$GaugeGroups[[h0, 2]]]}],
		{h0, 1, Length[M$GaugeGroups]}];
Nclist = Nclistpre;

(* Rules to create the Feynman rules from bilinears: *)
proprep = {};
Do[Do[
If[palist[[i, 1]] == "S" && palist[[j, 1]] == "S",
If[palist[[i, 2]]==palist[[j, 2]],
If[ToString[ToString[StandardForm[ToExpression[palist[[i, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[i, 2]]<>"bar"]]]],
proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]], \[Mu]_]) (del[ToExpression[palist[[j, 2]]], \[Mu]_]) -> 2 I p^2];
proprep = Append[proprep, (ToExpression[palist[[i, 2]]]) (ToExpression[palist[[j, 2]]]) -> 2 I],
	proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]<>"bar"], \[Mu]_]) (del[ToExpression[palist[[j, 2]]], \[Mu]_]) -> I p^2];
	proprep = Append[proprep, (ToExpression[palist[[i, 2]]<>"bar"]) (ToExpression[palist[[j, 2]]]) -> I]],
	If[ToString[ToString[StandardForm[ToExpression[palist[[i, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[i, 2]]<>"bar"]]]] && \
        ToString[ToString[StandardForm[ToExpression[palist[[j, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[j, 2]]<>"bar"]]]],
			proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]], \[Mu]_]) (del[ToExpression[palist[[j, 2]]], \[Mu]_]) -> I p^2];
			proprep = Append[proprep, (ToExpression[palist[[i, 2]]]) (ToExpression[palist[[j, 2]]]) -> I],
				proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]<>"bar"], \[Mu]_]) (del[ToExpression[palist[[j, 2]]], \[Mu]_]) -> I p^2];
				proprep = Append[proprep, (ToExpression[palist[[i, 2]]<>"bar"]) (ToExpression[palist[[j, 2]]]) -> I]]],
					If[palist[[i, 1]] == "V" && palist[[j, 1]] == "V",
					If[palist[[i, 2]]==palist[[j, 2]],
					If[ToString[ToString[StandardForm[ToExpression[palist[[i, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[i, 2]]<>"bar"]]]],
						If[ToString[(palist[[i, 2]] // ToExpression)] == myglu,
							proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Mu]_, a_], \[Mu]_]^2 -> 2 I fv[p, -J1] fv[p, -J2]];
							proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Mu]_, a_], \[Mu]_] del[ToExpression[palist[[i, 2]]][\[Nu]_, a_], \[Nu]_] -> 2 I fv[p, -J1] fv[p, -J2]];
							proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Nu]_, a_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Nu]_, a_], \[Mu]_] -> 2 I mt[-J1, -J2] p^2];
							proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Nu]_, a_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Mu]_, a_], \[Nu]_] -> 2 I fv[p, -J1] fv[p, -J2]],
								proprep = Append[proprep, ToExpression[palist[[i, 2]]][\[Mu]_]*ToExpression[palist[[j, 2]]][\[Mu]_] -> 2 I mt[-J1, -J2]];
								proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Mu]_], \[Mu]_]^2 -> 2 I fv[p, -J1] fv[p, -J2]];
								proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Mu]_], \[Mu]_] del[ToExpression[palist[[i, 2]]][\[Nu]_], \[Nu]_] -> 2 I fv[p, -J1] fv[p, -J2]];
								proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Nu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Nu]_], \[Mu]_] -> 2 I mt[-J1, -J2] p^2];
								proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Nu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Mu]_], \[Nu]_] -> 2 I fv[p, -J1] fv[p, -J2]]],
									proprep = Append[proprep, ToExpression[palist[[i, 2]]<>"bar"][\[Mu]_]*ToExpression[palist[[j, 2]]][\[Mu]_] -> I mt[-J1, -J2]];
									proprep = Append[proprep, del[ToExpression[palist[[i, 2]]<>"bar"][\[Mu]_], \[Mu]_]*del[ToExpression[palist[[i, 2]]][\[Nu]_], \[Nu]_] -> I fv[p, -J1] fv[p, -J2]];
									proprep = Append[proprep, del[ToExpression[palist[[i, 2]]<>"bar"][\[Nu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Nu]_], \[Mu]_] -> I mt[-J1, -J2] p^2];
									proprep = Append[proprep, del[ToExpression[palist[[i, 2]]<>"bar"][\[Nu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Mu]_], \[Nu]_] -> I fv[p, -J1] fv[p, -J2]]],
										If[ToString[ToString[StandardForm[ToExpression[palist[[i, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[i, 2]]<>"bar"]]]] && \
										    ToString[ToString[StandardForm[ToExpression[palist[[j, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[j, 2]]<>"bar"]]]],
												proprep = Append[proprep, ToExpression[palist[[i, 2]]][\[Mu]_]*ToExpression[palist[[j, 2]]][\[Mu]_] -> I mt[-J1, -J2]];
												proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Mu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Nu]_], \[Nu]_] -> I fv[p, -J1] fv[p, -J2]];
												proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Nu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Nu]_], \[Mu]_] -> I mt[-J1, -J2] p^2];
												proprep = Append[proprep, del[ToExpression[palist[[i, 2]]][\[Nu]_], \[Mu]_]*del[ToExpression[palist[[j, 2]]][\[Mu]_], \[Nu]_] -> I fv[p, -J1] fv[p, -J2]]]],
													If[palist[[i, 1]] == "F" && palist[[j, 1]] == "F", 
													proprep = Append[proprep, ToExpression[palist[[i, 2]] <> "bar . " <> palist[[j, 2]]] -> I];
													proprep = Append[proprep, ToExpression[palist[[i, 2]] <> "bar . del[" <> palist[[j, 2]] <> ",Index[Lorentz,\[Mu]_]]"] -> ToExpression["fv[p,\[Mu]]"]],
														If[palist[[i, 1]] == "U" && palist[[j, 1]] == "U",
															If[ToString[(palist[[i, 2]] // ToExpression)] == myglugh,
																proprep = Append[proprep, ToExpression[palist[[i, 2]]<>"bar"][a_].(del[del[ToExpression[palist[[j, 2]]][a_], \[Mu]_], \[Mu]_]) -> - I p^2];
																proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]<>"bar"][a_], \[Mu]_]).(del[ToExpression[palist[[j, 2]]][a_], \[Mu]_]) -> I p^2];
																proprep = Append[proprep, (ToExpression[palist[[i, 2]]<>"bar"][a_]) (ToExpression[palist[[j, 2]]][a_]) -> I],
																	proprep = Append[proprep, ToExpression[palist[[i, 2]]<>"bar"].(del[del[ToExpression[palist[[j, 2]]], \[Mu]_], \[Mu]_]) -> - I p^2];
																	proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]<>"bar"], \[Mu]_]).(del[ToExpression[palist[[j, 2]]], \[Mu]_]) -> I p^2];
																	proprep = Append[proprep, (ToExpression[palist[[i, 2]]<>"bar"]) (ToExpression[palist[[j, 2]]]) -> I]],
																		If[palist[[i, 1]] == "S" && palist[[j, 1]] == "V",
																			If[ToString[ToString[StandardForm[ToExpression[palist[[i, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[i, 2]]<>"bar"]]]] && \
																			ToString[ToString[StandardForm[ToExpression[palist[[j, 2]]<>"bar"]]]] == ToString[ToString[InputForm[ToExpression[palist[[j, 2]]<>"bar"]]]],
																			proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]], \[Mu]_]) ToExpression[palist[[j, 2]]][\[Mu]_] -> I fv[p, -J1]];
																			proprep = Append[proprep, ToExpression[palist[[i, 2]]] del[ToExpression[palist[[j, 2]]][\[Mu]_], \[Mu]_] -> - I fv[p, -J1]],
																				proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]<>"bar"], \[Mu]_]) ToExpression[palist[[j, 2]]][\[Mu]_] -> I fv[p, -J1]];
																				proprep = Append[proprep, ToExpression[palist[[i, 2]]<>"bar"] del[ToExpression[palist[[j, 2]]][\[Mu]_], \[Mu]_] -> I fv[p, -J1]];
																				proprep = Append[proprep, (del[ToExpression[palist[[i, 2]]], \[Mu]_]) ToExpression[palist[[j, 2]]<>"bar"][\[Mu]_] -> I fv[p, -J1]];
																				proprep = Append[proprep, ToExpression[palist[[i, 2]]] del[ToExpression[palist[[j, 2]]<>"bar"][\[Mu]_], \[Mu]_] -> I fv[p, -J1]]]]]]]], {j,1,Length[palist]}],{i, 1, Length[palist]}];

(* Convert the propagators FeynCalc-style notation to FeynRules notation *)
myprops = {fv -> FV, mt -> ME}

(* Multiply all elements of list *)
listProduct[x_List] := Times @@ x

(* Ok; what follows concerns the \[Eta]s: a very useful tool to obtain Feynman rules for propagators and counterterms *)
(* Create a different \[Eta] for each particle: *)
fixetas={};
Do[fixetas=Append[fixetas,ToExpression["\[Eta]" <> ToString[palist3[[i,2]]]]];
If[ToString[ToString[StandardForm[ToExpression[ToString[palist3[[i, 2]]]<>"bar"]]]] != ToString[ToString[InputForm[ToExpression[ToString[palist3[[i, 2]]]<>"bar"]]]],
fixetas=Append[fixetas,ToExpression["\[Eta]" <> ToString[palist3[[i,2]]] <>"bar"]]],{i,1,Length[palist3]}];

(* Create a generic \[Eta], associated to each different \[Eta]: *)
genetas={};
Do[genetas=Append[genetas,fixetas[[i]]->fixetas[[i]]*\[Eta]mygen],{i,1,Length[fixetas]}];

(* Insert the \[Eta]s in the equations: *)
insetas={};
Do[
insetas = Append[insetas, palist3[[i,2]] -> palist3[[i,2]] ToExpression["\[Eta]" <> ToString[palist3[[i,2]]]]];
If[ToString[ToString[StandardForm[ToExpression[ToString[palist3[[i, 2]]]<>"bar"]]]] != ToString[ToString[InputForm[ToExpression[ToString[palist3[[i, 2]]]<>"bar"]]]],
insetas = Append[insetas, ToExpression[ToString[palist3[[i, 2]]]<>"bar"] ->
										ToExpression[ToString[palist3[[i, 2]]]<>"bar"] ToExpression["\[Eta]" <> ToString[palist3[[i, 2]]]<>"bar"]]],{i,1,Length[palist3]}];
(* Replace fields for their \[Eta]s: *)
justetas={};
Do[
justetas = Append[justetas, palist3[[i,2]] -> ToExpression["\[Eta]" <> ToString[palist3[[i,2]]]]];
If[ToString[ToString[StandardForm[ToExpression[ToString[palist3[[i, 2]]]<>"bar"]]]] != ToString[ToString[InputForm[ToExpression[ToString[palist3[[i, 2]]]<>"bar"]]]],
justetas = Append[justetas, ToExpression[ToString[palist3[[i, 2]]]<>"bar"] ->
										ToExpression["\[Eta]" <> ToString[palist3[[i, 2]]]<>"bar"]]],{i,1,Length[palist3]}];
(* Set the derivatives of the \[Eta]s to zero *)
consrules = {};
Do[consrules = Append[consrules, del[fixetas[[i]], \[Mu]_] -> 0], {i, 1, Length[fixetas]}];
(* Take the \[Eta]s out of the fermionic products: *)
repsetas={};
Do[
repsetas = Append[repsetas, (fixetas[[i]] x_) . y_ -> fixetas[[i]] (x.y)];
repsetas = Append[repsetas, x_ . (fixetas[[i]] y_) -> fixetas[[i]] (x.y)],{i,1,Length[fixetas]}];
repsetas = Append[repsetas, (\[Eta]\[Delta] x_) . y_ -> \[Eta]\[Delta] (x.y)];
repsetas = Append[repsetas, x_ . (\[Eta]\[Delta] y_) -> \[Eta]\[Delta] (x.y)];
(* Take the \[Eta]s out of the 4vector definitions: *)
stilletas={};
Do[
stilletas = Append[stilletas, (x_ fixetas[[i]])[mu_] -> fixetas[[i]] x[mu]];
stilletas = Append[stilletas, (x_ fixetas[[i]])[mu_,a_] -> fixetas[[i]] x[mu,a]],{i,1,Length[fixetas]}];
(* Take all the \[Eta]s to zero: *)
cleanetas = {};
Do[cleanetas = Append[cleanetas, fixetas[[i]] ->0], {i, 1, Length[fixetas]}];
(* Take all the \[Eta]s to one: *)
unitetas = {};
Do[unitetas = Append[unitetas, fixetas[[i]] ->1], {i, 1, Length[fixetas]}];
(* comeback is going to be useful to convert combetas (in renormalization) into a list (CTord) crucial to print the counterterms *)
comeback={};
Do[comeback = Append[comeback, fixetas[[i]] -> ToExpression[StringDrop[fixetas[[i]] // ToString, 1]]],{i,1,Length[fixetas]}];
(* Distribute the fermionic product: *)
dotexpa = {(a_ + b_).x_ -> a.x + b.x, x_ .(a_ + b_) -> x.a + x.b, (a_ + b_ + c_).x_ -> a.x + b.x + c.x, x_ .(a_ + b_ + c_) -> x.a + x.b + x.c};
(* Create \[Eta]s for each propagator: *)
propsetas = {};
Do[
If[ToString[InputForm[palist3[[i, 1]]]]!="F"&&ToString[InputForm[palist3[[i, 1]]]]!="W",
If[ToString[ToString[StandardForm[ToExpression[ToString[palist3[[i, 2]]] <> "bar"]]]] != ToString[ToString[InputForm[ToExpression[ToString[palist3[[i, 2]]] <> "bar"]]]], 
   propsetas = Append[propsetas, ToExpression["\[Eta]" <> ToString[palist3[[i, 2]]] <> "bar"]*ToExpression["\[Eta]" <> ToString[palist3[[i, 2]]]]],
   propsetas = Append[propsetas, ToExpression["\[Eta]" <> ToString[palist3[[i, 2]]]]^2]]], {i, 1, Length[palist3]}];
(* Associate the corresponding type and name of particle to the \[Eta]s for the propagators: *)
propstypes = {};
propsnames = {};
Do[If[ToString[InputForm[palist3[[i, 1]]]]!="F"&&ToString[InputForm[palist3[[i, 1]]]]!="W",
propstypes = Append[propstypes, palist3[[i, 1]]];
propsnames = Append[propsnames, palist2[[i, 2]]]], {i, 1, Length[palist3]}];

(* ---------------- MyTeXForm: function to convert expressions into LaTeX style ---------------- *)
MyTeXForm = Function[exp, Module[{},
	str = OpenWrite["dataFR.m"];
	WriteString[str, InputForm[exp]];
    Close[str];
	If[osswitch=="Windows",
			str = OpenWrite["MyBatch.bat"];
			WriteString[str, "@echo off \n"];
			WriteString[str, "move dataFR.m ",StringReplace[dirNuc,"/"->"\\"],"\n"];
		    WriteString[str, "move FRtoTeX.m ",StringReplace[dirNuc,"/"->"\\"],"\n"];
		    WriteString[str, "cd ",StringReplace[dirNuc,"/"->"\\"],"\n"];
		    WriteString[str, "py JustConvert.py \n"];
		    WriteString[str, "del dataFR.m \n"];
		    WriteString[str, "move FRtoTeX.m ",StringReplace[dirFRmod,"/"->"\\"],"\n"];
		    WriteString[str, "move MyTeXForm-last-output.tex ",StringReplace[dirFRmod,"/"->"\\"],"\n"];
		    WriteString[str, "rmdir __pycache__ /S /Q \n"];
		    WriteString[str, "pause \n"];
		    Close[str];
		    Run["MyBatch.bat"];
    		DeleteFile["MyBatch.bat"];
    		(*(ReadString["MyTeXForm-last-output.tex"] // OutputForm) // InputForm*)
    		ReadString["MyTeXForm-last-output.tex"],
	If[osswitch=="Linux"||osswitch=="Mac",
			str = OpenWrite["MyBatch.sh"];
			WriteString[str, "mv dataFR.m ",dirNuc,"\n"];
		    WriteString[str, "mv FRtoTeX.m ",dirNuc,"\n"];
		    WriteString[str, "cd ",dirNuc,"\n"];
		    WriteString[str, "python3 JustConvert.py \n"];
		    WriteString[str, "rm dataFR.m \n"];
		    WriteString[str, "mv FRtoTeX.m ",dirFRmod,"\n"];
		    WriteString[str, "mv MyTeXForm-last-output.tex ",dirFRmod,"\n"];
		    WriteString[str, "rm -fr __pycache__  \n"];
		    WriteString[str, "cd ..\n"];
		    WriteString[str, "rm -fr __pycache__  \n"];
		    Close[str];
		    Run["sh MyBatch.sh"];
    		DeleteFile["MyBatch.sh"];
    		(*(ReadString["MyTeXForm-last-output.tex"] // OutputForm) // InputForm*)
    		ReadString["MyTeXForm-last-output.tex"]]]]];


(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
        We now define functions and variables related to renormalization
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)

Clear[p]; Clear[r];
(* Set the derivatives of the renormalization constants to zero *)
Do[consrules = Append[consrules, del[renconsadd[[i]], \[Mu]_] -> 0], {i, 1, Length[renconsadd]}];

(* Preparing the Lagrangean for the counterterms *)
(* Note: I cannot apply ExpandIndices to some sectors, either because this function uses the restrictions
of the restrictions file (which in some cases is undesirable, for they assume tad = 0), or because it
converts to 4spinors;*)

LEIGauge = 0;
LEIHiggs = 0;
LEIGhost = 0;
LEIGF = 0;
LEIFermions = 0;
LEIYukawa = 0;

If[ToString[InputForm[LGauge]] != "LGauge", LEIGauge = ExpandIndices[LGauge]];
If[ToString[InputForm[LHiggs]] != "LHiggs", LEIHiggs = MyExpandIndices[LHiggs]];
If[GFreno,If[ToString[InputForm[LGhost]] != "LGhost", LEIGhost = ExpandIndices[LGhost]]];
If[GFreno,If[ToString[InputForm[LGF]] != "LGF", LEIGF = MyExpandIndices[LGF]]];
If[ToString[InputForm[LFermions]] != "LFermions", LEIFermions = MyExpandIndices[LFermions]];
If[ToString[InputForm[LYukawa]] != "LYukawa", LEIYukawa = MyExpandIndices[LYukawa]];


(* Expand the renormalization rules: *)
renorrules = renorrules // Expand;

(* renps2 contains only the rhs terms of renps *)
renps2={};
Do[renps2 = Append[renps2, renps[[i,2]]], {i, 1, Length[renps]}];

(* renotricks contains some replacement rules due to counterterms that appear in denominators *)
If[ToString[InputForm[renotricks]] == "renotricks", renotricks = {}];
Do[
renotricks = Append[renotricks, (renps2[[i]])^(n_)  -> Normal[Series[(renps2[[i]])^n, {CTcor[[i]], 0, 1}]]];
renotricks = Append[renotricks, f_[renps2[[i]]]  -> Normal[Series[f[renps2[[i]]], {CTcor[[i]], 0, 1}]]];
renotricks = Append[renotricks, (f_[renps2[[i]]]+e_*g_[renps2[[i]]])^(n_) -> Normal[Series[(f[renps2[[i]]]+e*g[renps2[[i]]])^n, {CTcor[[i]], 0, 1}]]],
{i, 1, Length[renps2]}];

(* For the case in which the user did not define a RenoPreRep function *)
If[ToString[RenoPreRep//InputForm]=="RenoPreRep",RenoPreRep=Function[exp,exp]];

(* Insert an \[Eta]\[Delta] for each \[Delta] constant: *)
insetdel = {};
Do[insetdel = Append[insetdel, renconsadd[[i]] -> \[Eta]\[Delta] renconsadd[[i]]], {i, 1, Length[renconsadd]}];
(* Define \[Eta]\[Delta] as a real number: *)
nomat = {HC[\[Eta]\[Delta]] -> \[Eta]\[Delta], Conjugate[x_ \[Eta]\[Delta]] -> Conjugate[x] \[Eta]\[Delta]};

(* Take the non-matricial Deltas out of the fermionic products: *)
repsdeltas={};
Do[
repsdeltas = Append[repsdeltas, (renconscar[[i]] x_) . y_ -> renconscar[[i]] (x.y)];
repsdeltas = Append[repsdeltas, x_ . (renconscar[[i]] y_) -> renconscar[[i]] (x.y)],{i,1,Length[renconscar]}];

(* Put Dirac slashed in a pretty form *)
gamrep = {Ga[Index[Lorentz, mu_]].ProjM*fv[p_, mu_] -> DiracGamma[Momentum[p]].ProjM,\
					Ga[Index[Lorentz, mu_]].ProjP*fv[p_, mu_] -> DiracGamma[Momentum[p]].ProjP,\
				  Ga[Index[Lorentz, mu_]]*fv[p_, mu_] -> DiracGamma[Momentum[p]],
          Ga[mu_].ProjM*fv[p_, mu_] -> DiracGamma[Momentum[p]].ProjM,\
          Ga[mu_].ProjP*fv[p_, mu_] -> DiracGamma[Momentum[p]].ProjP,\
          Ga[mu_]*fv[p_, mu_] -> DiracGamma[Momentum[p]]};

(* Rules to get rid of the annoying internal FeynRules indices: *)
indrep = {
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",

					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",

					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",

					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Generation, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
					"[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Generation, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Generation, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",
          "[Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Generation, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "], Index[Colour, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]]" -> "",

          ", Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ "]" -> "",
          ", Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _~~ _ ~~ "]" -> "",
          ", Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _~~ _ ~~ "]" -> "",
          ", Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _~~ _ ~~"], Index[Spin, " ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _ ~~ _~~ _ ~~ "]" -> ""
          };

(* Rules to create the Feynman rules from tadpoles: *)
tadrep={};
Do[If[palist[[i, 1]] == "S",tadrep = Append[tadrep, ToExpression[palist[[i, 2]]] -> I]], {i,1,Length[palist]}];

(* A couple of functions to speed up the calculation of ExpandIndices *)

NewExpInd=Function[{arg1,arg2},Module[{myext},
If[ToString[InputForm[arg2]]=="0",
myext=ExpandIndices[arg1],
myext=ExpandIndices[arg1,arg2]];
myext]];

LoCTStep=Function[{exp,step,minp,maxp},Module[{extra,mylen,mybip,F0,F1,LoCTaux},
(* *)
extra=0;
If[minp!=0,extra=MinParticles -> minp];
If[maxp!=0,extra=MaxParticles -> maxp];
(* *)
mylen=exp//Length;
mybip=QuotientRemainder[exp//Length,step];
LoCTaux=0;
Do[
  F0=Sum[exp[[j]],{j,i*step+1,i*step+step}];
  F1=NewExpInd[F0,extra];
  LoCTaux+=F1,{i,0,mybip[[1]]-1}];
If[mybip[[2]]!=0,F0=Sum[exp[[j]],{j,mybip[[1]]*step+1,mybip[[1]]*step+mybip[[2]]}];
  F1=NewExpInd[F0,extra];
  LoCTaux+=F1];
LoCTaux]];

MyInCount=0;

combetas={};
ancCTve2tot={};

(* Some instructions should the user want to debug the renormalization *)
DeBug=False;
newcoin=0;
MDB=Function[str,
If[DeBug,
newcoin+=1;
WriteString[str, StringForm["Time used up to now: `` minutes.\n",TimeUsed[]/60]];
WriteString[str, StringForm["Flag `` .\n",newcoin]]]];


(* GetCT is the main function of renormalization of the FeynMaster model *)
GetCT=Function[exp,Module[{},

If[DeBug,
MyInCount+=1;
str5 = OpenWrite[ToString[StringForm["MyProgress``.m", MyInCount]]]];

(*exp2,DotsLogic,WeylsLogic,LwCTpre,LwCTpre2,LwCT,LwCT2,LwCT3,LwCT4,LwCT5,LoCTpre,
                              LoCT,LoCT2,LoCT3,LoCT4,LoCT5,LoCT6,LoCT7,LoCT8,LoCT9,LoCT10,
                              LoCTproppre1,LoCTproppre2,LoCTproppre3,LoCTprop,LoCTpropntad,
                              ancCTve1,ancCTve2,LoCTvert,LoCTans*)
exp2= exp // InputForm // ToString;
DotsLogic=StringContainsQ[exp2,"."];
WeylsLogic = False;
Do[If[StringFreeQ[exp2, MyWeyls[[i]]],
    Continue,
    WeylsLogic = True;
    Break], {i, 1, Length[MyWeyls]}];
MDB[str5];
LwCTpre = RenoPreRep[exp];
MDB[str5];
LwCTpre2 = (((LwCTpre /. renorrules) /. renotricks) /. consrules) /. renotricks;
MDB[str5];
If[DotsLogic,
LwCT = LwCTpre2 //. dotexpa,
LwCT = LwCTpre2];
MDB[str5];
LwCT2 = LwCT /. insetdel /. nomat;
MDB[str5];
If[DotsLogic,
LwCT3 = LwCT2 //. repsetas;
LwCT4 = LwCT3 //. repsdeltas,
LwCT4 = LwCT2];
MDB[str5];
LwCT5 = LwCT4 /. MyRestr;
MDB[str5];
LoCTpre=0;
If[ToString[LwCT5//Head]=="Plus",
Do[LoCTpre+=Coefficient[LwCT5[[i]],\[Eta]\[Delta],1],{i,1,Length[LwCT5]}],
LoCTpre=Coefficient[LwCT5,\[Eta]\[Delta],1]];
MDB[str5];
If[WeylsLogic,
  LoCT = WeylToDirac[LoCTpre],
  LoCT = LoCTpre];
MDB[str5];
If[DotsLogic,
    LoCT2 = LoCTStep[LoCT,5,0,0],
    LoCT2 = LoCT];
MDB[str5];
LoCT3 = StringReplace[ToString[LoCT2 // InputForm], indrep];
MDB[str5];
LoCT4 = ToExpression[LoCT3];
MDB[str5];
LoCT5 = Expand[LoCT4 /. notensdots /. todots];
MDB[str5];
LoCT6 = (LoCT5 /. insetas) /. consrules;
MDB[str5];
If[DotsLogic,
    LoCT7 = Expand[(LoCT6 //. repsetas) //. repsdeltas],
    LoCT7 = LoCT6];
MDB[str5];
LoCT8 = LoCT7 /. stilletas;
MDB[str5];
LoCT9 = LoCT8 /. consrules;
MDB[str5];
LoCT10 = LoCT9 /. genetas;

(* - - specific operations for propagators and tadpoles: - - *)
(* LoCTproppre1 =  LoCTStep[LoCT9,5,0,2]; *)
LoCTproppre1 = Coefficient[LoCT10, \[Eta]mygen, 0] + Coefficient[LoCT10, \[Eta]mygen, 1] + Coefficient[LoCT10, \[Eta]mygen, 2];
MDB[str5];
LoCTproppre2 = StringReplace[ToString[LoCTproppre1 // InputForm], indrep];
MDB[str5];
LoCTproppre3 = ToExpression[LoCTproppre2];
MDB[str5];
LoCTprop = Expand[LoCTproppre3 /. proprep];
MDB[str5];
LoCTpropntadpre = Expand[LoCTprop /. tadrep];
MDB[str5];
LoCTpropntad = LoCTpropntadpre //. MyRestr;
MDB[str5];
ser1=List@@LoCTpropntad;
etant={};
Do[sla1=1;
ser2=List@@ser1[[i]];
Do[If[StringTake[ToString[ser2[[j]]//InputForm],1]=="\[Eta]",If[ToString[ser2[[j]]//Head]=="Power",If[MemberQ[fixetas,ser2[[j,1]]],sla1=sla1*ser2[[j]]],If[MemberQ[fixetas,ser2[[j]]],sla1=sla1*ser2[[j]]]]],{j,1,Length[ser2]}];
If[ToString[sla1//InputForm]!="1",etant=Append[etant,sla1]],{i,1,Length[ser1]}];
etbef=etant//DeleteDuplicates;
Do[If[! MemberQ[combetas,etbef[[i]]], combetas=Append[combetas,etbef[[i]]]],{i,1,Length[etbef]}];
MDB[str5];

(* - - specific operations for vertices: - - *)
ancCTve1 = Coefficient[LoCT10, \[Eta]mygen, 3] + Coefficient[LoCT10, \[Eta]mygen, 4];
MDB[str5];
ancCTve2 = FeynmanRules[ancCTve1];
MDB[str5];
If[ancCTve2!={},Do[ancCTve2tot=Append[ancCTve2tot,ancCTve2[[j]]],{j,1,Length[ancCTve2]}]];
MDB[str5];
anc2={};
Do[
anc1={};
Do[anc1=Append[anc1,ancCTve2[[i,1,j,1]]/.justetas],{j,1,Length[ancCTve2[[i,1]]]}];
anc2=Append[anc2,listProduct[anc1]],{i,1,Length[ancCTve2]}];
etpre=anc2//DeleteDuplicates;
Do[If[! MemberQ[combetas,etpre[[i]]], combetas=Append[combetas,etpre[[i]]]],{i,1,Length[etpre]}];
MDB[str5];
LoCTvert = 0;
(* Do[LoCTvert += (Simplify[ancCTve2[[i,2]]] /. MyRestr /. MyRestr),{i,1,Length[ancCTve2]}];*)
Do[LoCTvert += (ancCTve2[[i,2]] //. MyRestr),{i,1,Length[ancCTve2]}];
MDB[str5];
LoCTvert=Expand[LoCTvert];
(* - - final Lagrangean for the counterterms: - - *)
MDB[str5];
If[DeBug,Close[str5]];
LoCTans = LoCTpropntad + LoCTvert
]];

(* GetCT2=Function[exp,Module[{}, GetCT[exp] /. unitetas]]; *)