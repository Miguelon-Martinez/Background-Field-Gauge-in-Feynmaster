(* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
This is the Definitions.m file, a Mathematica routine for FeynCalc where we make some useful definitions and replacement rules.

Created by: Duarte Fontes
Email: duartefontes@tecnico.ulisboa.pt
Last update: 09.10.2020
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *)

(* ---------------- FeynMaster signature ---------------- *)
Print["This Notebook was automatically generated by FeynMaster."];
Print["FeynMaster: created by Duarte Fontes and Jorge C. Romão."];
Print["Version " <> FMversion <> " (" <> FMdate <> ")"];
Print["Please cite: Comput.Phys.Commun. 256 (2020) 107311, arXiv: 1909.05876."];
Print["Please do not forget to cite FeynRules, QGRAF and FeynCalc as well"];

(* ---------------- Some tricks concerning Passarino-Veltman ---------------- *)
PaVeTrick = {
	PaVe[0, {}, {x_}]->A0[x],
	PaVe[0, {}, {x_}, yy_, ww_]->A0[x],
	PaVe[0, {x_}, {y_,z_}] -> B0[x,y,z],
	PaVe[0, {x_}, {y_,z_}, yy_, ww_] -> B0[x,y,z],
	PaVe[1, {x_}, {y_,z_}] -> B1[x,y,z]};
MyPaVeReduce[x_]:= ((((PaVeReduce[x] /. {D -> 4}) + GetFinite[PaVeReduce[x]])//FCE)/.PaVeTrick)//DiracSimplify
SetOptions[B1, BReduce -> False];

(* * * * * * Options for version 9.3 of FeynCalc: * * * * * *)
FCVersion=StringDrop[$FeynCalcVersion, -2] // ToExpression;
If[FCVersion>=9.3,
SetOptions[DiracSimplify, ToDiracGamma67 -> False];
SetOptions[DiracSimplify, SpinorChainTrick -> False];
SetOptions[ComplexConjugate, FCRenameDummyIndices -> False]];
(* SetOptions[DiracTrace, DiracTraceEvaluate -> True]; *)
(* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *)

If[ToString[Options[Total][[1,1]]]=="AllowedHeads",
SetOptions[Total, AllowedHeads -> All]];

(* ---------------- Källén function ---------------- *)
MyKallen[x_,y_,z_]:= Sqrt[x^2+y^2+z^2- 2(x*y + x*z + y*z)]

(* ---------------- FM directory ---------------- *)
dirFM=StringDrop[dirNuc, -8];

(* ------------------- Some useful rules and definitions concerning Dirac matrices and momenta ------------------- *)
distG5 = {x_ .(((1 - GA[5])/2)) -> x/2 - (x.GA[5])/2, x_ .(((1 + GA[5])/2)) -> x/2 + (x.GA[5])/2, x_ .((1 - GA[5])) -> x - x.GA[5], x_ .((1 + GA[5])) -> x + x.GA[5]};
ProjP=(1+dm[5])/2; ProjM=(1-dm[5])/2;
stilldot = {FV[p_, mu_]*GA[mu_] -> GS[p], GA[mu_].GA[5]*FV[p_, mu_] -> GS[p].GA[5]};
myfad = {FAD[x_, Dimension -> 4] -> 1/SP[x, x], FAD[{x_, z_}] -> 1/(SP[x, x]-z^2)};
expsp = {SP[x_ + y_, z_ + w_] -> SP[x, z] + SP[x, w] + SP[y, z] + SP[y, w],
			SP[-x_,-y_]->SP[x,y], SP[-x_,y_]->-SP[x,y], SP[x_,-y_]->-SP[x,y]};

(* ------------------- Some useful definitions concerning the intervening particles ------------------- *)
Inparticles:=ToString[inparticlesA]
NumberIn:=Length[inparticlesB]
If[ToString[ToExpression[outparticlesA] // InputForm] != "outparticlesA",
	Outparticles:=ToString[outparticlesA];
	NumberOut:=Length[outparticlesB]]

(* ------------------- Momentum conservation ------------------- *)
MomCons={};
If[NumberIn == 1 &&  NumberOut == 1, MomCons={FV[q1, x_] -> FV[p1, x], q1 -> p1}];
If[NumberIn == 1 &&  NumberOut == 2, MomCons={FV[p1, x_] -> FV[q1, x] + FV[q2, x], GS[p1] -> GS[q1] + GS[q2], p1 -> q1 + q2}];
If[NumberIn == 2 &&  NumberOut == 1, MomCons={FV[q1, x_] -> FV[p1, x] + FV[p2, x], GS[q1] -> GS[p1] + GS[p2], q1 -> p1 + p2}];
If[NumberIn == 2 &&  NumberOut == 2, MomCons={FV[q1, x_] -> FV[p1, x] + FV[p2, x] - FV[q2, x], GS[q1] -> GS[p1] + GS[p2] - GS[q2], q1 -> p1 + p2 - q2}];
ApplyMomCons={};
If[MoCoLogic == True,ApplyMomCons=MomCons];

(* ----------- Two important functions: GetAns and GetRes ----------- *)
(* Note: the (1/I) in the prefactors that follow assure that the final result is M, and not iM *)
Prefac:= (1/I) (I/(16 Pi^2)) (1/(I Pi^2))
PrefacTree := (1/I)
If[loops==0,
GetAns[amp_,k_]:= Simplify[(PrefacTree Calc[ChangeTo4[amp]]) // SUNSimplify],
GetAns[amp_,k_]:= Prefac OneLoopTID[k,amp] // SUNSimplify];
GetRes[ans_]:= ((1/factor) * ((ChangeTo4[ans]) + ChangeTo4[GetFinite[ans]])) /. {DiracTrace -> Tr}
(* GetRes[ans_]:=((1/factor) * ((ChangeTo4[ans]) + ChangeTo4[GetFinite[ans]])) *)

